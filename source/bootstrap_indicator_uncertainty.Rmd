---
title: "Calculate biodiversity indicator uncertainty"
subtitle: "Bootstrapping"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning=FALSE, message=FALSE}
# Load packages
library(b3gbi)     # Biodiversity indicators for data cubes
library(tidyverse) # Data wrangling and visualisation
library(here)      # Relative paths

# Source functions
source(here("source", "scripts", "evenness_formula.R"))
source(here("source", "scripts", "boot_statistic.R"))
source(here("source", "scripts", "perform_bootstrap.R"))
source(here("source", "scripts", "bootstrap_list_to_df.R"))
source(here("source", "scripts", "get_bootstrap_ci.R"))
source(here("source", "scripts", "utils.R"))
```

# Exploration of the b3gbi package

We install b3gbi package version 0.2.1.
We load a dataset from the package.
How does the cube look like?

```{r}
# Load GBIF data cube
cube_name <- system.file("extdata", "europe_insect_cube.csv", package = "b3gbi")

# Load taxonomic info for cube
tax_info <- system.file("extdata", "europe_insect_info.csv", package = "b3gbi")

insect_data_df <- read.csv(cube_name)
head(insect_data_df)
```

We process the cube.

```{r}
# Prepare cube
insect_data <- process_cube_old(cube_name, tax_info)

insect_data
```

> Where did the info on min. coordinate uncertainty in meters go?

```{r}
# Calculate diversity metric
map_obs_rich_insects <- obs_richness_map(insect_data)

print(map_obs_rich_insects)
```

```{r}
# Plot diversity metric
plot(map_obs_rich_insects,
     title = "Observed Species Richness: Insects in Europe")
```

## Calculate an index over time

Let's calculate Pietlou's eveness over time using b3gbi.

```{r}
eveness_insect_data <- pielou_evenness_ts(insect_data)
head(eveness_insect_data)
```

```{r}
plot(eveness_insect_data)
```

> Visualisation of trend not correct.

Let's calculate this metric from scratch.
We select the data after 2010 to ensure calculations with enough data.

```{r}
insect_data_new <- insect_data$data %>%
  group_by(year) %>%
  mutate(n = sum(obs)) %>%
  ungroup() %>%
  filter(year > 2010) %>%
  select(-n)

insect_data_new %>%
  group_by(year) %>%
  summarise(n_obs = sum(obs)) %>%
  ggplot() +
    geom_bar(aes(x = as.factor(year), y = n_obs), stat = "identity") +
    labs(x = "year", y = "number of observations")
```

## Bootstrapping

We perform bootstrapping for evenness (`boot::boot()`).
Bootstrapping is a statistical technique used to estimate the distribution of a statistic by resampling with replacement from the original data.
Below are the common notations used in bootstrapping:

1. **Original Sample Data**: $\mathbf{X} = \{X_1, X_2, \ldots, X_n\}$
    - The initial set of observed data points. Here, $n$ is the sample size.

2. **Bootstrap Sample**: $\mathbf{X}^* = \{X_1^*, X_2^*, \ldots, X_n^*\}$
    - A sample of size $n$ drawn with replacement from the original sample $\mathbf{X}$. Each $X_i^*$ is drawn independently from $\mathbf{X}$.

3. **Statistic of Interest**: $\theta$
    - The parameter or statistic being estimated, such as the mean $\bar{X}$, variance $\sigma^2$, or median.

4. **Bootstrap Replication**: $\hat{\theta}^*_b$
    - The value of the statistic of interest calculated from the $b$-th bootstrap sample $\mathbf{X}^*_b$. For example, if $\theta$ is the sample mean, $\hat{\theta}^*_b = \bar{X}^*_b$.

5. **Number of Bootstrap Samples**: $B$
    - The number of bootstrap samples drawn from the original data. Common choices for $B$ are 1000 or 10,000 to ensure a good approximation of the distribution.

6. **Bootstrap Estimate of the Statistic**: $\hat{\theta}_{\text{boot}}$
    - The average of the bootstrap replications:

$$
\hat{\theta}_{\text{boot}} = \frac{1}{B} \sum_{b=1}^B \hat{\theta}^*_b
$$

7. **Bootstrap Standard Error**: $\text{SE}_{\text{boot}}$
    - The standard deviation of the bootstrap replications, which estimates the variability of the statistic.

8. **Bootstrap Bias**: $\text{Bias}_{\text{boot}}$
    - This bias indicates how much the bootstrap estimate deviates from the original sample estimate. It is calculated as the difference between the average bootstrap estimate and the original estimate:

$$
\text{Bias}_{\text{boot}} = \frac{1}{B} \sum_{b=1}^B (\hat{\theta}^*_b - \hat{\theta})
$$

8. **Bootstrap Confidence Interval**
    - Confidence intervals for the statistic of interest can be constructed using the bootstrap distribution of $\hat{\theta}^*$. Several methods are explained below.


```{r}
# Bootstrapping
bootstrap_insect_data <- perform_bootstrap(
  data_cube_df = insect_data_new,
  fun = evenness_formula,
  samples = 1000,
  seed = 123)

# Summarise in dataframe
bootstrap_insect_data_full <- bootstrap_list_to_df(bootstrap_insect_data)
```

We get confidence intervals (`boot::boot.ci()`) and add it to the dataframe.
There are five types of intervals that can be calculated.
The default calculates all intervals.

Davison, A.C. & Hinkley, D.V. (1997). *Bootstrap Methods and Their Application*, Chapter 5. Cambridge University Press.

**1. Normal approximation** (normal)

Assuming the bootstrap distribution of the statistic is approximately normal.

$$
\left[ \hat{\theta} - \text{Bias}_{\text{boot}} - \text{SE}_{\text{boot}} \times z_{1-\alpha/2}, \hat{\theta} - \text{Bias}_{\text{boot}} + \text{SE}_{\text{boot}} \times z_{1-\alpha/2} \right]
$$

where $z_{1-\alpha/2}$ is the $1-\alpha/2$ quantile of the standard normal distribution for $\alpha$ confidence level.

**2. Basic bootstrap method** (basic)

Centering the interval around the original estimate $\hat{\theta}$.

$$
\left[ 2\hat{\theta} - \hat{\theta}^*_{(1-\alpha/2)}, 2\hat{\theta} - \hat{\theta}^*_{(\alpha/2)} \right]
$$

where $\hat{\theta}^*_{(\alpha/2)}$ and $\hat{\theta}^*_{(1-\alpha/2)}$ are the $\alpha/2$ and $1-\alpha/2$ percentiles of the bootstrap distribution, respectively.

**3. Studentized bootstrap method** (studentized)

Similar as **1**, but $z_{1-\alpha/2}$ estimated based on the bootstrap distribution.

**4. Bootstrap percentile method** (percent)

Using the percentiles of the bootstrap distribution.

$$
\left[ \hat{\theta}^*_{(\alpha/2)}, \hat{\theta}^*_{(1-\alpha/2)} \right]
$$

where $\hat{\theta}^*_{(\alpha/2)}$ and $\hat{\theta}^*_{(1-\alpha/2)}$ are the $\alpha/2$ and $1-\alpha/2$ percentiles of the bootstrap distribution, respectively.

> There is a slight difference!

**5. Adjusted bootstrap percentile method (Bias-Corrected and Accelerated, BCa)** (bca)

Adjusting for bias and skewness in the bootstrap distribution.

$$
\left[ \hat{\theta}^*_{(\alpha_1)}, \hat{\theta}^*_{(\alpha_2)} \right]
$$

where $\alpha_1$ and $\alpha_2$ are adjusted percentiles taking into account the bias and acceleration (adjust for skewness).

Because evenness is a value between 0 and 1, we calculate the intervals under the logit transformation.
The intervals are calculated on the scale of $h(t)$

$$
h(t) = \text{logit}(t) = \text{log}\left(\frac{t}{1 - t}\right)
$$
Afterwards, the inverse function $h_{\text{inv}}(l)$ applied to the resulting intervals.

$$
h_{\text{inv}}(l) = \text{inv_logit}(l) = \frac{e^l}{1 + e^l}
$$

```{r}
# Calculate confidence intervals
ci_df <- get_bootstrap_ci(bootstrap_insect_data, h = logit, hinv = inv_logit)

# Join dataframes
bootstrap_insect_data_final <- bootstrap_insect_data_full %>%
  full_join(ci_df, by = join_by(year), relationship = "many-to-many")
```

Calculation of studentized intervals failed.
Its use is further explained in `?boot::boot.ci()`.

## Visualise confidence intervals

```{r}
numbers_data <- insect_data_new %>%
  group_by(year) %>%
  summarize(num_occ = sum(.data$obs),
            num_spec = n_distinct(taxonKey),
            .groups = "drop") %>%
  mutate(label_occ = paste("n_occ", num_occ, sep = "="),
         label_spec = paste("n_spec", num_spec, sep = "="),
         label_tot = paste(label_occ, label_spec, sep = "\n"))
```

We visualise the distribution of the bootstrap replicates.
The red dots are the the original sample estimates $\hat{\theta}$.

```{r, fig.width = 10}
bootstrap_insect_data_final %>%
  ggplot(aes(x = year)) +
    geom_boxplot(aes(y = est_boot, group = year)) +
    geom_point(aes(y = est_original), colour = "firebrick", size = 3) +
    geom_label(data = numbers_data, aes(y = 1.1, label = label_tot),
               size = 3, label.padding = unit(0.35, "lines")) +
    labs(y = "evenness") +
    scale_y_continuous(limits = c(0, 1.1), breaks = seq(-10, 10, 0.25)) +
    scale_x_continuous(breaks = sort(unique(bootstrap_insect_data_final$year)))
```

```{r, fig.width = 10}
bootstrap_insect_data_final %>%
  ggplot(aes(x = year)) +
    geom_violin(aes(y = est_boot, group = year)) +
    geom_point(aes(y = est_original), colour = "firebrick", size = 3) +
    geom_label(data = numbers_data, aes(y = 1.1, label = label_tot),
               size = 3, label.padding = unit(0.35, "lines")) +
    labs(y = "evenness") +
    scale_y_continuous(limits = c(0, 1.1), breaks = seq(-10, 10, 0.25)) +
    scale_x_continuous(breaks = sort(unique(bootstrap_insect_data_final$year)))
```

We visualise the confidence intervals.

```{r, fig.width = 10}
bootstrap_insect_data_final %>%
  distinct(year, est_original, se_boot, int_type, ll, ul, conf_level) %>%
  ggplot(aes(x = year, y = est_original)) +
    geom_errorbar(aes(ymin = ll, ymax = ul, colour = int_type),
                  position = position_dodge(0.8), linewidth = 1) +
    geom_point(aes(group = int_type), colour = "firebrick", size = 3,
               position = position_dodge(0.8)) +
    labs(y = "evenness", colour = "Confidence interval") +
    geom_label(data = numbers_data, aes(y = 1.1, label = label_tot),
             size = 3, label.padding = unit(0.35, "lines")) +
    theme(legend.position = "bottom") +
    scale_y_continuous(limits = c(NA, 1.1), breaks = seq(-10, 10, 0.25)) +
    scale_x_continuous(breaks = sort(unique(bootstrap_insect_data_final$year)))
```

We compare the confidence intervals with the distribution of the bootstrap replicates.

```{r, fig.width = 10}
bootstrap_insect_data_final %>%
  ggplot(aes(x = year)) +
    geom_boxplot(aes(y = est_boot, group = year)) +
    geom_errorbar(aes(ymin = ll, ymax = ul, colour = int_type),
                  position = position_dodge(0.8), linewidth = 1) +
    geom_point(aes(y = est_original), colour = "firebrick", size = 3) +
    geom_label(data = numbers_data, aes(y = 1.1, label = label_tot),
               size = 3, label.padding = unit(0.35, "lines")) +
    labs(y = "evenness", colour = "Confidence interval") +
    theme(legend.position = "bottom") +
    scale_y_continuous(limits = c(0, 1.1), breaks = seq(-10, 10, 0.25)) +
    scale_x_continuous(breaks = sort(unique(bootstrap_insect_data_final$year)))
```

```{r, fig.width = 10}
bootstrap_insect_data_final %>%
  ggplot(aes(x = year)) +
    geom_violin(aes(y = est_boot, group = year)) +
    geom_errorbar(aes(ymin = ll, ymax = ul, colour = int_type),
                  position = position_dodge(0.8), linewidth = 1) +
    geom_point(aes(y = est_original), colour = "firebrick", size = 3) +
    geom_label(data = numbers_data, aes(y = 1.1, label = label_tot),
               size = 3, label.padding = unit(0.35, "lines")) +
    labs(y = "evenness", colour = "Confidence interval") +
    theme(legend.position = "bottom") +
    scale_y_continuous(limits = c(NA, 1.1), breaks = seq(-10, 10, 0.25)) +
    scale_x_continuous(breaks = sort(unique(bootstrap_insect_data_final$year)))
```

There is quite some difference in interval width when values are small.
Then, the basic and normal intervals are much smaller than bca and percent.

The interval width of percent increases when the bootstrap standard error increases.
The interval width of basic decreases when the bootstrap standard error increases.
We also see a decreasing trend for normal.

```{r}
bootstrap_insect_data_final %>%
  mutate(ci_width = ul - ll) %>%
  distinct(year, se_boot, int_type, ci_width) %>%
  ggplot(aes(x = se_boot, y = ci_width, colour = int_type)) +
    geom_point() +
    geom_smooth(method = "lm", formula = "y ~ x") +
    labs(x = "bootstrap standard error", y = "interval width",
         colour = "Confidence\ninterval")
```

```{r}
bootstrap_insect_data_final %>%
  mutate(ci_width = ul - ll) %>%
  distinct(year, se_boot, int_type, ci_width) %>%
  group_by(int_type) %>%
  group_modify(~ grouped_regression(df = ., formula = ci_width ~ se_boot)) %>%
  ungroup() %>%
  filter(param == "se_boot") %>%
  knitr::kable()
```

We see the same when we look at bias.

```{r}
bootstrap_insect_data_final %>%
  mutate(ci_width = ul - ll) %>%
  distinct(year, bias_boot, int_type, ci_width) %>%
  ggplot(aes(x = bias_boot, y = ci_width, colour = int_type)) +
    geom_point() +
    geom_smooth(method = "lm", formula = "y ~ x") +
    labs(x = "bootstrap standard error", y = "interval width",
         colour = "Confidence\ninterval")
```

```{r}
bootstrap_insect_data_final %>%
  mutate(ci_width = ul - ll) %>%
  distinct(year, bias_boot, int_type, ci_width) %>%
  group_by(int_type) %>%
  group_modify(~ grouped_regression(df = ., formula = ci_width ~ bias_boot)) %>%
  ungroup() %>%
  filter(param == "bias_boot") %>%
  knitr::kable()
```

There is some discussion on the use of [the percentile interval](https://stats.stackexchange.com/questions/355781/is-it-true-that-the-percentile-bootstrap-should-never-be-used).
The BCa approach takes into account both bias and skewness and seems to be the best approach for this situation.

# Interpretation and visualisation of uncertainty

Here we will follow the methods implemented by the [effectclass package](https://inbo.github.io/effectclass/).
It classifies effects by comparing a coverage interval with a reference, lower and upper threshold.
The benefits of this approach are twofold:

1. A visual tool that simplifies interpretation of results, even for people who are not familiar with the data and/or methods used
2. The use of arbitrary thresholds allows to make the distinction between 'no effect' (small interval covering reference) and 'uncertain effect' (large interval covering reference and one or both thresholds)
